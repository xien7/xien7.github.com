<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyBatis学习笔记（五） 级联]]></title>
    <url>%2F2017%2F10%2F30%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%94%EF%BC%89-%E7%BA%A7%E8%81%94%2F</url>
    <content type="text"><![CDATA[数据库是一个面向表和行的关系模型，而Java是面向类和对象的继承模式，并且Java中提供了丰富的集合，来表示对象之间的关联。解决Java的关联模型和数据库的关联模型，是ORM框架的另一个问题。 一对一 associationMyBatis用association来表示一对一的关系，例如每一个Blog都有唯一的Category。 数据库模型12345678910111213CREATE TABLE blogs ( id INT AUTO_INCREMENT, content VARCHAR(256) NOT NULL, PRIMARY KEY(id));CREATE TABLE categories ( id INT AUTO_INCREMENT, blog_id INT, name VARCHAR(64) NOT NULL, PRIMARY KEY(id), FOREIGN KEY (blog_id) REFERENCES blogs(id) ON DELETE CASCADE); Java对象模型1234567891011class Blog &#123; private Integer id; private String content; private Category category;&#125;class Category &#123; private Integer id; private Integer blogId; private String name;&#125; MyBatis 映射文件:blog.xml123456789101112&lt;mapper namespace="com.xien.example.BlogDao"&gt; &lt;resultMap id="blogMap" type="com.xien.example.Blog"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="content" column="content"/&gt; &lt;association property="category" column="id" select="com.xien.example.CategoryDao.CategoryByBlogId"/&gt; &lt;/resultMap&gt; &lt;select id="getBlog" parameterType="int" resultMap="blogMap"&gt; SELECT id, content FROM blogs WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; category.xml1234567891011&lt;mapper namespace="com.xien.example.CategoryDao"&gt; &lt;resultMap id="categoryMap" type="com.xien.example.Category"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="blogId" column="blog_id"/&gt; &lt;result property="name" column="name"/&gt; &lt;/resultMap&gt; &lt;select id="CategoryByBlogId" parameterType="int" resultMap="categoryMap"&gt; SELECT id, blog_id, name FROM categories WHERE blog_id=#&#123;blogId&#125; &lt;/select&gt;&lt;/mapper&gt; ##总结 通过blog.xml中ResultMap的定义，我们可以知道Blog的category字段，是一个一对一的关联，它对应的查询方法是 “com.xien.example.CategoryDao.CategoryByBlogId”，并且将Blog的id作为参数传递过去。 MyBatis在查询一个Blog的时候，分为两个查询。第一步，通过BlogDao.getBlog查询出Blog；第二步，根据Blog的id，调用com.xien.example.CategoryDao.CategoryByBlogId查询对应的Category。（如果设置了延迟加载，那么第二部只有到调用Blog.getCategory()时才会去加载Category） 一对多 collectionJava中除了一对一的关联，还存在这一对多的关联，通过容器来包含多个其它对象。举个例子，博客系统中，每一个Blog存在着０到N个Comments。 数据库模型1234567891011121314CREATE TABLE blogs ( id INT AUTO_INCREMENT, content VARCHAR(256) NOT NULL, PRIMARY KEY(id));CREATE TABLE comments ( id INT AUTO_INCREMENT, blog_id INT, content VARCHAR(144) NOT NULL, create_at DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP(), PRIMARY KEY(id), FOREIGN KEY(blog_id) REFERENCES blogs(id) ON DELETE CASCADE); Java对象模型123456789101112class Blog &#123; private Integer id; private String content; private List&lt;Comment&gt; comment;&#125;class Comment &#123; private Integer id; private Integer blogId; private String content; private Date createdAt;&#125; MyBatis 映射文件:blog.xml123456789101112&lt;mapper namespace="com.xien.example.BlogDao"&gt; &lt;resultMap id="blogMap" type="com.xien.example.Blog"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="content" column="content"/&gt; &lt;collection property="comments" column="id" select="com.xien.example.CommentDao.getCommentByBlogId" &lt;/resultMap&gt; &lt;select id="getBlog" parameterType="int" resultMap="blogMap"&gt; SELECT id, content FROM blogs WHERE id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; comment.xml123456789101112&lt;mapper namespace="com.xien.example.CommentDao"&gt; &lt;resultMap id="commentMap" type="com.xien.example.Comment"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="blogId" column="blog_id"/&gt; &lt;result property="content" column="content"/&gt; &lt;result property="createdAt" column="created_at"/&gt; &lt;/resultMap&gt; &lt;select id="getCommentByBlogId" parameterType="int" resultMap="commentMap"&gt; SELECT id, blog_id, content, created_at FROM comments WHERE blog_id=#&#123;blogId&#125; &lt;/select&gt;&lt;/mapper&gt; 总结和一对一类似，唯一的区别是POJO中，换成了List，映射文件中也对应的变成了 多对多所有的多对多关系，都可以转换成为对应的两个一对多。例如在博客系统中，每一个Blog可以有多个Tag，相应的，每一个Tag可以有多个Blog。 数据库模型1234567891011121314151617181920CREATE TABLE blogs ( id INT AUTO_INCREMENT, content VARCHAR(256) NOT NULL, PRIMARY KEY(id));CREATE TABLE tags ( id INT AUTO_INCREMENT, name VARCHAR(64) NOT NULL, PRIMARY KEY(id));CREATE TABLE blog_tags ( id INT AUTO_INCREMENT, blog_id INT, tag_id INT, PRIMARY KEY(id), FOREIGN KEY (blog_id) REFERENCES blogs(id) ON DELETE CASCADE, FOREIGN KEY (tag_id) REFERENCES tags(id) ON DELETE CASCADE); 数据库中，我们不直接让blogs和tags进行关联，而是引入了第三个表blog_tags，它分别和blogs以及tags进行一对多的关联。 Java对象模型1234567891011class Blog &#123; private Integer id; private String content; private List&lt;Tag&gt; Tags;&#125;class Tag &#123; private Integer id; private String name; private List&lt;Blog&gt; blogs;&#125; MyBatis 映射文件:blog.xml12345678910111213141516&lt;mapper namespace="com.xien.example.BlogDao"&gt; &lt;resultMap id="blogMap" type="com.xien.example.Blog"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="content" column="content"/&gt; &lt;collection property="tags" column="id" fetchType="lazy" select="com.xien.example.TagDao.getTagByBlogId"/&gt; &lt;/resultMap&gt; &lt;select id="getBlog" parameterType="int" resultMap="blogMap"&gt; SELECT id, content FROM blogs WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id="getBlogByTagId" parameterType="int" resultMap="blogMap"&gt; SELECT b.id, b.content FROM blogs AS b JOIN blog_tags AS bt ON b.id = bt.blog_id WHERE bt.tag_id = #&#123;tagId&#125; &lt;/select&gt;&lt;/mapper&gt; tag.xml12345678910111213141516&lt;mapper namespace="com.xien.example.TagDao"&gt; &lt;resultMap id="tagMap" type="com.xien.example.Tag"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;collection property="blogs" column="id" fetchType="lazy" select="com.xien.example.BlogDao.getBlogByTagId"/&gt; &lt;/resultMap&gt; &lt;select id="getTag" parameterType="int" resultMap="tagMap"&gt; SELECT id, name FROM tags WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id="getTagByBlogId" parameterType="int" resultMap="tagMap"&gt; SELECT t.id, t.name FROM tags AS t JOIN blog_tags AS bt ON t.id = bt.tag_id WHERE bt.blog_id = #&#123;blogId&#125; &lt;/select&gt;&lt;/mapper&gt; 总结和一对多类似，这里两方分别制定了一对多。有一点注意的是fetchType都设置成了lazy，避免一次加载过多的数据。 鉴别器 discriminatorJava中存在这继承的关联，而数据库是没有这种关系的。ＭyBatis通过鉴别器，达到这种需求。举个例子，有一个基类Animal，它有两个派生类Dog和Fish 数据库模型123456789101112131415161718CREATE TABLE animals ( id INT AUTO_INCREMENT, name VARCHAR(32) NOT NULL, type INT NOT NULL, PRIMARY KEY(id));CREATE TABLE dogs ( id INT, fur_color VARCHAR(32), FOREIGN KEY (id) REFERENCES animals(id) ON DELETE CASCADE);CREATE TABLE fishes ( id INT, has_bone BOOLEAN NOT NULL DEFAULT TRUE, FOREIGN KEY (id) REFERENCES animals(id) ON DELETE CASCADE); Java对象模型123456789101112class Animal &#123; private Integer id; private String name;&#125;class Dog &#123; private String furColor;&#125;class Fish &#123; private boolean hasBone;&#125; MyBatis 映射文件:animal.xml1234567891011121314151617181920212223242526272829303132&lt;mapper namespace="com.xien.example.AnimalDao"&gt; &lt;resultMap id="animalMap" type="com.xien.example.Animal"&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="name"/&gt; &lt;discriminator javaType="int" column="type"&gt; &lt;case value="1" resultMap="dogMap"/&gt; &lt;case value="2" resultMap="fishMap"/&gt; &lt;/discriminator&gt; &lt;/resultMap&gt; &lt;resultMap id="dogMap" type="com.xien.example.Dog" extends="animalMap"&gt; &lt;result property="furColor" column="fur_color"/&gt; &lt;/resultMap&gt; &lt;resultMap id="fishMap" type="com.xien.example.Fish" extends="animalMap"&gt; &lt;result property="hasBone" column="has_bone"/&gt; &lt;/resultMap&gt; &lt;select id="getAnimal" parameterType="int" resultMap="animalMap"&gt; SELECT id, name, type FROM animals WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id="getDog" parameterTYpe="int" resultMap="dogMap"&gt; SELECT fur_color FROM dogs WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id="getFish" parameterType="int" resultMap="fishMap"&gt; SELECT has_bone FROM fishes WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 总结从上面可以看出，resultMap是可以继承和扩展的，并且通过基类中的一个字段来区别是哪一个子resultMap。discriminator 类似于switch case 语句，通过一个字段的各种case（值）来决定属于那个子类。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（四） 运行周期]]></title>
    <url>%2F2017%2F10%2F27%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E8%BF%90%E8%A1%8C%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[MyBatis 执行一条SQL语句，主要有以下三个步骤： 解析并准备SQL 绑定参数 转换结果 下面主要按照这三个步骤来看它是如何执行的，开发者可以怎样定制这些流程。 解析并准备SQLMyBatis会提取Mapper映射文件中的语句（混合了SQL，Tag 和表达式），并且对它进行解析成为待执行SQL。 动态SQLMyBatis 支持在语句中嵌入某些XML的Tag，以便于根据输入参数，来动态的改变待执行SQL语句 include这是一个最简单的tag，支持引入映射文件中定义的字符串，通常用来定义查询需要的列名。 1234567&lt;sql id="user_columns"&gt; id, name, description&lt;/sql&gt;&lt;select id="getUsers" resultType="com.xien.example.pojo.UserBean"&gt; SELECT &lt;include refid="user_columns"/&gt; FROM users&lt;/select&gt; if结合它的test属性一起使用，通常用来有条件的包含where子句的一部分，例如 12345678910&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; test中，可以以字符串的形式，书写简单的条件判断表达式。但是它不能有else或者else if，所以只能有一个分支 choose, when, otherwise类似于Java中的switch，或者 if… else if … else。用于多个条件判断。例如 123456789101112131415&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test="title != null"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where,trim假设存在以下一个例子 1234567891011121314&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE &lt;if test="state != null"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; 如果所有条件都无法匹配，最终生成的结果会是什么样子的？ 12SELECT * FROM BLOGWHERE 如果只有title这个条件匹配上呢？ 123SELECT * FROM BLOGWHERE AND title like ‘someTitle’ 以上的两条语句都是非法的，如何解决这个问题呢？ 如果只有一个条件判断，那么可以用改写: 123456789&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test="state != null"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 只有当where中的条件成立时，它才会在语句中插入一个WHERE。 如果是多个条件的话，可以用trim改写： 123456789101112131415&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG &lt;trim prefix="WHERE" prefixOverrides="AND | OR"&gt; &lt;if test="state != null"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; trim会在某一个条件达成时，在语句前插入prefix定义的内容(相应的也支持suffix)；并且会对第一个满足条件的语句，将包含prefixOverrides定义的前缀给去掉(相应的也支持suffixOverrides)。 set在Hibernate中，如果要更新对象，需要把所有的字段都发送给数据库进行更新，即使只有一个字段真正的变化了。而在MyBatis中，通过set可以很好的解决部分字段更新的问题。 12345678910&lt;update id="updateAuthorIfNecessary"&gt; update Author &lt;set&gt; &lt;if test="username != null"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test="email != null"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test="bio != null"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; set能帮我们自动处理每个条件的语句结尾的逗号，这里等同于 123&lt;trim prefix="SET" suffixOverrides=","&gt; ...&lt;/trim&gt; foreach在我们的查询中，有可能会用到IN关键字，而IN附带的列表往往是不能事先确定的，需要动态根据参数生成的。MyBatis通过foreach来实现这个过程： 123456789&lt;select id="selectPostIn" resultType="domain.blog.Post"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; foreach 支持对数组，List, Set等集合的遍历，也支持Map，具有以下属性： collection，必须属性，指定对哪一个集合进行遍历 index，对应了集合中键的名字，如果是数组或者列表，则其值为下标；如果是Map，其值为key item，对应了集合中value的名字 open，生成语句的前缀 close，生成语句的后缀 separator，每个元素之间的分隔符 More Detailssee dynamic sql 类型处理SQL的数据类型是有限的，但是Java的数据类型是多种多样的。MyBatis在预处理语句(PreparedStatement)中设置参数，或者从结果集中(ResultSet)取出一个值时，都会用注册了的TypeHandler进行处理。MyBatis内置了许多TypeHandler，可以实现大部分功能，而用户也可以自定义TypeHandler. TypeHandler常用的配置为Java类型(javaType)和JDBC类型(jdbcType)。它的作用就是将参数从javaType转化为jdbcType；或者从数据库取出结果时，把jdbcType转化为javaType。它的定义如下: 1234567891011public interface TypeHandler&lt;T&gt; &#123; void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException; T getResult(ResultSet rs, String columnName) throws SQLException; T getResult(ResultSet rs, int columnIndex) throws SQLException; T getResult(CallableStatement cs, int columnIndex) throws SQLException;&#125; T 为需要处理的javaType setParameter，将javaType对应的参数，转化为jdbcType，并设置到PreparedStatement中 三个getResult，表示通过ResultSet用列名，下表和CallableStatement中获取结果，并且转化为对应的javaType. 实现完我们自己的TypeHandler之后，需要在XML文件中注册到MyBatis， 123&lt;typeHandlers&gt; &lt;typeHandler jdbcType="VARCHAR" javaType="string" handler="com.xien.example.MyTypeHandler"/&gt;&lt;/typeHandlers&gt; 目前，这个TypeHandler只是被注册到MyBatis，还并不会被使用到。我们还需要在具体需要使用的地方，通过jdbcType+javaType或者直接typeHandler进行配置。 绑定参数经历了第一步后，用户的语句会转换为待执行的语句。类似于 1SELECT id, name, description FROM users WHERE id = #&#123;id&#125; 这个时候MyBatis需要做两个步骤： 从用户传入的参数中，找到名字为id的java对象 利用预定义的或者自定义的typeHandler，将java对象，转换成为jdbc类型，然后设置到语句中。 参数传递一般情况下额，MyBatis都支持传递一个参数，这个参数可以是简单的基本类型，也可以是复杂的Bean或者其它方式。但是可以通过以下三种方式传递多个参数: Map: 通过Ｍap的方式一次传递多个参数，但是会造成可读写的下降，以及无法编译时检查参数 使用@Param注解，多个参数通过@Param分别命名。当参数个数&lt;= 5是比较号的方式 1public UserBean findUserByNameAndDescription(@Param("name")String name, @Param("description")String description); 通过JavaBean，当参数多于5个 指定TypeHandler在绑定参数时想使用已经注册的自定义TypeHandler，可以在参数表达式中指定 12345UPDATE users SET description = #&#123;description, jdbcType=VARCHAR, javaType=string&#125; WHERE id=#&#123;id&#125;ORUPDATE users SET description = #&#123;description, typeHandler=com.xien.example.MyTypeHandler&#125; WHERE id=#&#123;id&#125; # 无需提前在配置中注册. 转换结果这一步骤负责把SQL查询的结果转换为Java对象 自动映射如果结果是简单的基础类型，或者是简单的JavaBean，则可以通过resultType直接设置类型。MyBatis支持通过反射直接转换结果，它要求JavaBean的属性名和SQL返回的列明匹配（驼峰命名法)。如果数据库使用下划线分隔单词的规范，可以将mapUnderscoreToCamelCase设置为true，也可以实现自动映射。 ResultMap对于复杂（名字不匹配，含有自定义类型的POJO，包含关联）的结果类型，则需要自己定义ResultMap来确定转换规则。ResultMap的定义如下： 123456789101112131415&lt;resultMap&gt; &lt;constructor&gt; &lt;idArg/&gt; &lt;arg/&gt; &lt;/constructor&gt; &lt;id/&gt; &lt;result/&gt; &lt;association/&gt; &lt;collection/&gt; &lt;discriminator&gt; &lt;case/&gt; &lt;/discriminator&gt;&lt;/resultMap&gt; constructor 是用构造器的方式来构造结果 idArg和id用来定义主键，可以有一个或者多个字段构成主键 idArg和arg用来定义每一个构造器参数的转换规则 id和result用来定义每个属性(setter)的转换规则 association, collection和discriminator用来定义关联。 例子: 12345&lt;resultMap&gt; &lt;id property="id" column="id"/&gt; &lt;result property="name" column="user_name" jdbcType="VARCHAR" javaType="string"/&gt; &lt;result property="description" column="description" typeHandler="com.xien.example.TypeHandler"/&gt;&lt;/resultMap&gt;]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（三） 对象生命周期]]></title>
    <url>%2F2017%2F10%2F27%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[之前的例子中涉及到了MyBatis的主要组件和基本用法，本篇文章介绍它们的生命周期，这是十分重要的，利于MyBatis应用的正确性和高性能。 SqlSessionFactoryBuilder它是利用XML或者Java编码来获取资源并构建SqlSessionFactory。 它唯一的作用就是构建一个多个SqlSessionFactory。 一旦构建完成，它的生命周期就已经完结。所以一般它都只存在与局部方法中，构建完成后就被回收。 SqlSessionFactory它的作用是用来创建SqlSession，而SqlSession就是一个会话，相当于JDBC中的Connection对象。每次需要访问数据库时，都需要通过SqlSessionFactory创建一个SqlSession。 它的生命周期是每一个数据库在应用程序里面全局唯一，并且和应用程序的生命周期一致。因为它会用到线程池，所以如果对一个数据库创建多个实例，会造成Connection过多小号，并且不利于统一管理。 SqlSessionSqlSession是一个会话，处理一次事务中的多条语句。 它的生命周期应该是在请求数据库处理事务的过程中。 它是一个线程不安全对象，不能共享；并且需要被几时关闭，避免资源浪费。 MapperMapper是一个接口，没有任何实现类。它的作用是发送SQL，然后返回我们需要的结果，或者执行SQL从而修改数据库的数据。 它应该在一个SqlSession事务方法之内，是一个方法级别的对象。它的最大范围和SqlSession是相同的。尽量在一个SqlSession事务的方法中去获取它们，然后废弃掉。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（二） Example]]></title>
    <url>%2F2017%2F10%2F27%2FMybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-Example%2F</url>
    <content type="text"><![CDATA[本篇文章会搭建一个完备的简单的MyBatis程序。所有代码都是基于MyBatis 3.4.0进行的 Step１ Database创建数据库对应的表 1234567CREATE TABLE users ( id INT AUTO_INCREMENT, name VARCHAR(64) NOT NULL, description VARCHAR(255) NOT NULL DEFAULT &apos;&apos;, INDEX(name), PRIMARY KEY(id)) ENGINE = Innodb CHARSET = &apos;utf8&apos;; 创建了一个users的表，它有三个字： 一个自增长的主键id 一个VARCHAR类型的name字段，并且为它创建索引 一个VARCHAR类型的description字段 并且使用了Innodb作为存储引擎，字符集是UTF-8。 相关的POJO对象： 123456789package com.xien.example.pojo;public class UserBean &#123; private Integer id; private String name; private String description; // related getters and setters&#125; Step 2 MyBatis Configuration接下来需要创建MyBatis的配置文件mybatis-config.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3.config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/user"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value=""/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="user.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; MyBatis的配置文件是一个XML文件，在本例中，它只有简单的两个元素： environment, 负责配置一个环境，可以配置多个环境，以便在开发，测试时使用不同的环境。一个环境包含两个部分 transactionManager: 事务管理器，本例中使用JDBC事务管理 dataSource：数据库连接信息，本例中使用连接池 mappers, 定义映射器，本例中只有一个映射器 Step 3 Mapper接下来就该定义我们业务相关的映射器了。映射器是由一个Java接口和一个XML文件组成。 123456789101112131415package com.xien.example.dao;public interface UserDao &#123; public List&lt;UserBean&gt; getUsers(RowsBounds rowBounds); public UserBean getUser(Integer id); public UserBean getUserByName(String userName); public int insertUser(UserBean user); public int updateUser(UserBean user); public int deleteUser(Integer id);&#125; 12345678910111213141516171819202122232425262728293031&lt;?xml vesion=r"1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xien.example.dao.UserDao"&gt; &lt;sql id="user_columns"&gt; id, name, description &lt;/sql&gt; &lt;select id="getUsers" resultType="com.xien.example.pojo.UserBean"&gt; SELECT &lt;include refid="user_columns"/&gt; FROM users &lt;/select&gt; &lt;select id="getUser" parameterType="int" resultType="com.xien.example.pojo.UserBean"&gt; SELECT &lt;include refid="user_columns"/&gt; FROM users WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id="getUserByName" parameterType="string" resultType="com.xien.example.pojo.UserBean"&gt; SELECT &lt;include refid="user_columns"/&gt; FROM users WHERE name=#&#123;userName&#125; &lt;/select&gt; &lt;insert id="insertUser" parameterType="com.xien.example.pojo.UserBean"&gt; INSERT users(name, description) VALUE (#&#123;name&#125;, #&#123;description&#125;) &lt;/insert&gt; &lt;update id="updateUser" parameterType="com.xien.example.pojo.UserBean"&gt; UPDATE users SET name=#&#123;name&#125;, description=#&#123;description&#125; WHERE id=$&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteUser" parameterType="int"&gt; DELETE FROM users WHERE id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 至此，一个mapper定义完成了。可以看出来UserDao只是简单的定义了一些操作，包括它们名字，参数和返回值。这个接口方便开发者直接用Java进行调用，方便编译器的静态检查。另外，所有的SQL(业务逻辑)都是定义在XML映射文件中的。 namespace, 定义了这个映射对应的接口，也是一个命名空间。 sql, 这个是一个可选项，用来定义一个后面SQL语句中会经常用到的语句，本例中是列名，会被所有查询函数用到 select，表面这是一个查询的语句，id表面它对应的方法名。namespace + id = interface + method，既可以用来对应接口和映射文件，也可以用来全局唯一限定一个语句。 parameterType，用来指定参数类型的 resultType，用来指定返回的类型，MyBatis会自动识别返回的是一个对象还是一个对象的集合。 insert/update/delete，和select类型，只是它们默认的resultType是int, 表示SQL所影响的行数 Step 4 SqlSessionFactory &amp; SqlSession一切准备就绪了，可以把所有模块串在一起跑起来了 12345678910111213141516171819202122public class Example &#123; public static SqlSessionFactory getSqlSessionFactory() throw IOException &#123; String resource = "mybatis-config.xml"; return new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(resource)); &#125; public static void main(String[] args) &#123; try (SqlSession session = getSqlSessionFactory().openSession()) &#123; UserDao userDao = session.getMapper(UserDao.class); UserBean user1 = new UserBean(); user1.setId(1); user1.setName("Xien"); user1.setDescription("Just a programmer"); userDao.insertUser(user1); UserBean user2 = userDao.getUser(1); userDao.deleteUser(1); &#125; &#125;&#125; MyBatis 的核心是SqlSession，可以理解为一个Transaction，通过它来拿到一个Ｍapper接口(通过动态代理实现)，然后对POJO和数据库进行操作。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（一） 简介]]></title>
    <url>%2F2017%2F10%2F26%2FMybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[传统的JDBC编程JDBC(Java Data Base Connectivity) 是JAVA提供的数据库访问规范。典型的桥接模式，将各种数据库的访问抽象成一个同一的接口，再针对各种数据库，具体的实现。 初始化。（注册驱动，配置URL，Username，Password等配置）。Ｃlass.forName 是将具体的 Driver Class 加载到 JVM，然后通过它的静态初始化方法，把自身注册到 DriverManager 中。 获取Connection连接（通过 DriverManager 或者 DataSource ）。DriverManager 是典型的工厂方法模式，利用 URL的格式和参数，来创建对应的 Connection。 创建 Statement (包括PrepareStatement和CallableStatement) ，设置参数，执行SQL，查询请求会获取到ResultSet 通过ResultSet获得一行或多行数据。通过代码转换成POJO对象 关闭资源（ResultSet，Statement和Connection） 如果用到事务，还需要主动commit，以及捕获异常，然后rollback 这是通过JDBC操作数据库的一个标准流程，但是存在着很多问题： 工作量相对较大，大量重复的样板代码。重复是个坏味道; 需要对JDBC中可能出现的异常进行捕捉，处理，并且正确的关闭资源。 需要程序员自己解决 SQL 注入等安全问题 ORM由于JDBC的缺陷，实际工作中很少直接使用它(??) 于是提出了对象关系映射模型(ORM, Object Relational Mapping)。ORM就是关系型数据库表和简单Java对象( Plain Ordinary Java Object, 简称POJO)的映射关系模型。 Hibernate Hibernate 是一个流行的ORM框架，它具有以下特点： 消除了代码的映射规则，把它分离到XML或者注解的配置里 无需再手动管理数据库连接 无需再操作多个对象，只需要session即可，也只需要关闭session一个资源 但是它也是一个比较重的框架，基于全映射；不支持动态SQL；多表关联和复杂的SQL支持较差；不能很好的支持存储过程；虽然有HQL，但是性能较差 MyBatis MyBatis是一个半自动的持久化框架，它包含了SQL Maps和DAO(Data Access Objects)。除了提供映射关系以外，还需要我们自己提供SQL语句。它的映射文件包含了以下三个部分： SQL 映射规则 POJO 总结 JDBC在目前很少用到，它需要提供太多的代码，复杂的操作，还极其容易出问题 HIberate是一个流行全自动ORM的框架，但是因为它包装过多，失去了灵活性和性能 MyBatis是一个半自动的ORM框架，它提供了丰富而又灵活的功能。唯一的缺点是需要自己实现SQL，但也就是因为这样，给了程序员更好的灵活性。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
</search>
