<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MyBatis学习笔记（四） 运行周期]]></title>
    <url>%2F2017%2F10%2F27%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E8%BF%90%E8%A1%8C%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[MyBatis 执行一条SQL语句，主要有以下三个步骤： 解析并准备SQL 绑定参数 转换结果 下面主要按照这三个步骤来看它是如何执行的，开发者可以怎样定制这些流程。 解析并准备SQLMyBatis会提取Mapper映射文件中的语句（混合了SQL，Tag 和表达式），并且对它进行解析成为待执行SQL。 动态SQLMyBatis 支持在语句中嵌入某些XML的Tag，以便于根据输入参数，来动态的改变待执行SQL语句 include这是一个最简单的tag，支持引入映射文件中定义的字符串，通常用来定义查询需要的列名。 1234567&lt;sql id="user_columns"&gt; id, name, description&lt;/sql&gt;&lt;select id="getUsers" resultType="com.xien.example.pojo.UserBean"&gt; SELECT &lt;include refid="user_columns"/&gt; FROM users&lt;/select&gt; if结合它的test属性一起使用，通常用来有条件的包含where子句的一部分，例如 12345678910&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; test中，可以以字符串的形式，书写简单的条件判断表达式。但是它不能有else或者else if，所以只能有一个分支 choose, when, otherwise类似于Java中的switch，或者 if… else if … else。用于多个条件判断。例如 123456789101112131415&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test="title != null"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; where,trim假设存在以下一个例子 1234567891011121314&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE &lt;if test="state != null"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt;&lt;/select&gt; 如果所有条件都无法匹配，最终生成的结果会是什么样子的？ 12SELECT * FROM BLOGWHERE 如果只有title这个条件匹配上呢？ 123SELECT * FROM BLOGWHERE AND title like ‘someTitle’ 以上的两条语句都是非法的，如何解决这个问题呢？ 如果只有一个条件判断，那么可以用改写: 123456789&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG &lt;where&gt; &lt;if test="state != null"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 只有当where中的条件成立时，它才会在语句中插入一个WHERE。 如果是多个条件的话，可以用trim改写： 123456789101112131415&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG &lt;trim prefix="WHERE" prefixOverrides="AND | OR"&gt; &lt;if test="state != null"&gt; state = #&#123;state&#125; &lt;/if&gt; &lt;if test="title != null"&gt; AND title like #&#123;title&#125; &lt;/if&gt; &lt;if test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/if&gt; &lt;/trim&gt;&lt;/select&gt; trim会在某一个条件达成时，在语句前插入prefix定义的内容(相应的也支持suffix)；并且会对第一个满足条件的语句，将包含prefixOverrides定义的前缀给去掉(相应的也支持suffixOverrides)。 set在Hibernate中，如果要更新对象，需要把所有的字段都发送给数据库进行更新，即使只有一个字段真正的变化了。而在MyBatis中，通过set可以很好的解决部分字段更新的问题。 12345678910&lt;update id="updateAuthorIfNecessary"&gt; update Author &lt;set&gt; &lt;if test="username != null"&gt;username=#&#123;username&#125;,&lt;/if&gt; &lt;if test="password != null"&gt;password=#&#123;password&#125;,&lt;/if&gt; &lt;if test="email != null"&gt;email=#&#123;email&#125;,&lt;/if&gt; &lt;if test="bio != null"&gt;bio=#&#123;bio&#125;&lt;/if&gt; &lt;/set&gt; where id=#&#123;id&#125;&lt;/update&gt; set能帮我们自动处理每个条件的语句结尾的逗号，这里等同于 123&lt;trim prefix="SET" suffixOverrides=","&gt; ...&lt;/trim&gt; foreach在我们的查询中，有可能会用到IN关键字，而IN附带的列表往往是不能事先确定的，需要动态根据参数生成的。MyBatis通过foreach来实现这个过程： 123456789&lt;select id="selectPostIn" resultType="domain.blog.Post"&gt; SELECT * FROM POST P WHERE ID in &lt;foreach item="item" index="index" collection="list" open="(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; foreach 支持对数组，List, Set等集合的遍历，也支持Map，具有以下属性： collection，必须属性，指定对哪一个集合进行遍历 index，对应了集合中键的名字，如果是数组或者列表，则其值为下标；如果是Map，其值为key item，对应了集合中value的名字 open，生成语句的前缀 close，生成语句的后缀 separator，每个元素之间的分隔符 bind]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（三） 对象生命周期]]></title>
    <url>%2F2017%2F10%2F27%2FMyBatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[之前的例子中涉及到了MyBatis的主要组件和基本用法，本篇文章介绍它们的生命周期，这是十分重要的，利于MyBatis应用的正确性和高性能。 SqlSessionFactoryBuilder它是利用XML或者Java编码来获取资源并构建SqlSessionFactory。 它唯一的作用就是构建一个多个SqlSessionFactory。 一旦构建完成，它的生命周期就已经完结。所以一般它都只存在与局部方法中，构建完成后就被回收。 SqlSessionFactory它的作用是用来创建SqlSession，而SqlSession就是一个会话，相当于JDBC中的Connection对象。每次需要访问数据库时，都需要通过SqlSessionFactory创建一个SqlSession。 它的生命周期是每一个数据库在应用程序里面全局唯一，并且和应用程序的生命周期一致。因为它会用到线程池，所以如果对一个数据库创建多个实例，会造成Connection过多小号，并且不利于统一管理。 SqlSessionSqlSession是一个会话，处理一次事务中的多条语句。 它的生命周期应该是在请求数据库处理事务的过程中。 它是一个线程不安全对象，不能共享；并且需要被几时关闭，避免资源浪费。 MapperMapper是一个接口，没有任何实现类。它的作用是发送SQL，然后返回我们需要的结果，或者执行SQL从而修改数据库的数据。 它应该在一个SqlSession事务方法之内，是一个方法级别的对象。它的最大范围和SqlSession是相同的。尽量在一个SqlSession事务的方法中去获取它们，然后废弃掉。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（二） Example]]></title>
    <url>%2F2017%2F10%2F27%2FMybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89-Example%2F</url>
    <content type="text"><![CDATA[本篇文章会搭建一个完备的简单的MyBatis程序。所有代码都是基于MyBatis 3.4.0进行的 Step１ Database创建数据库对应的表 1234567CREATE TABLE users ( id INT AUTO_INCREMENT, name VARCHAR(64) NOT NULL, description VARCHAR(255) NOT NULL DEFAULT &apos;&apos;, INDEX(name), PRIMARY KEY(id)) ENGINE = Innodb CHARSET = &apos;utf8&apos;; 创建了一个users的表，它有三个字： 一个自增长的主键id 一个VARCHAR类型的name字段，并且为它创建索引 一个VARCHAR类型的description字段 并且使用了Innodb作为存储引擎，字符集是UTF-8。 相关的POJO对象： 123456789package com.xien.example.pojo;public class UserBean &#123; private Integer id; private String name; private String description; // related getters and setters&#125; Step 2 MyBatis Configuration接下来需要创建MyBatis的配置文件mybatis-config.xml 12345678910111213141516171819202122&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3.config.dtd"&gt;&lt;configuration&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;transactionManager type="JDBC"/&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/user"/&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value=""/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource="user.xml"/&gt; &lt;/mappers&gt; &lt;/configuration&gt; MyBatis的配置文件是一个XML文件，在本例中，它只有简单的两个元素： environment, 负责配置一个环境，可以配置多个环境，以便在开发，测试时使用不同的环境。一个环境包含两个部分 transactionManager: 事务管理器，本例中使用JDBC事务管理 dataSource：数据库连接信息，本例中使用连接池 mappers, 定义映射器，本例中只有一个映射器 Step 3 Mapper接下来就该定义我们业务相关的映射器了。映射器是由一个Java接口和一个XML文件组成。 123456789101112131415package com.xien.example.dao;public interface UserDao &#123; public List&lt;UserBean&gt; getUsers(RowsBounds rowBounds); public UserBean getUser(Integer id); public UserBean getUserByName(String userName); public int insertUser(UserBean user); public int updateUser(UserBean user); public int deleteUser(Integer id);&#125; 12345678910111213141516171819202122232425262728293031&lt;?xml vesion=r"1.0" encoding="utf-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.xien.example.dao.UserDao"&gt; &lt;sql id="user_columns"&gt; id, name, description &lt;/sql&gt; &lt;select id="getUsers" resultType="com.xien.example.pojo.UserBean"&gt; SELECT &lt;include refid="user_columns"/&gt; FROM users &lt;/select&gt; &lt;select id="getUser" parameterType="int" resultType="com.xien.example.pojo.UserBean"&gt; SELECT &lt;include refid="user_columns"/&gt; FROM users WHERE id=#&#123;id&#125; &lt;/select&gt; &lt;select id="getUserByName" parameterType="string" resultType="com.xien.example.pojo.UserBean"&gt; SELECT &lt;include refid="user_columns"/&gt; FROM users WHERE name=#&#123;userName&#125; &lt;/select&gt; &lt;insert id="insertUser" parameterType="com.xien.example.pojo.UserBean"&gt; INSERT users(name, description) VALUE (#&#123;name&#125;, #&#123;description&#125;) &lt;/insert&gt; &lt;update id="updateUser" parameterType="com.xien.example.pojo.UserBean"&gt; UPDATE users SET name=#&#123;name&#125;, description=#&#123;description&#125; WHERE id=$&#123;id&#125; &lt;/update&gt; &lt;delete id="deleteUser" parameterType="int"&gt; DELETE FROM users WHERE id=#&#123;id&#125; &lt;/delete&gt;&lt;/mapper&gt; 至此，一个mapper定义完成了。可以看出来UserDao只是简单的定义了一些操作，包括它们名字，参数和返回值。这个接口方便开发者直接用Java进行调用，方便编译器的静态检查。另外，所有的SQL(业务逻辑)都是定义在XML映射文件中的。 namespace, 定义了这个映射对应的接口，也是一个命名空间。 sql, 这个是一个可选项，用来定义一个后面SQL语句中会经常用到的语句，本例中是列名，会被所有查询函数用到 select，表面这是一个查询的语句，id表面它对应的方法名。namespace + id = interface + method，既可以用来对应接口和映射文件，也可以用来全局唯一限定一个语句。 parameterType，用来指定参数类型的 resultType，用来指定返回的类型，MyBatis会自动识别返回的是一个对象还是一个对象的集合。 insert/update/delete，和select类型，只是它们默认的resultType是int, 表示SQL所影响的行数 Step 4 SqlSessionFactory &amp; SqlSession一切准备就绪了，可以把所有模块串在一起跑起来了 12345678910111213141516171819202122public class Example &#123; public static SqlSessionFactory getSqlSessionFactory() throw IOException &#123; String resource = "mybatis-config.xml"; return new SqlSessionFactoryBuilder() .build(Resources.getResourceAsStream(resource)); &#125; public static void main(String[] args) &#123; try (SqlSession session = getSqlSessionFactory().openSession()) &#123; UserDao userDao = session.getMapper(UserDao.class); UserBean user1 = new UserBean(); user1.setId(1); user1.setName("Xien"); user1.setDescription("Just a programmer"); userDao.insertUser(user1); UserBean user2 = userDao.getUser(1); userDao.deleteUser(1); &#125; &#125;&#125; MyBatis 的核心是SqlSession，可以理解为一个Transaction，通过它来拿到一个Ｍapper接口(通过动态代理实现)，然后对POJO和数据库进行操作。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MyBatis学习笔记（一） 简介]]></title>
    <url>%2F2017%2F10%2F26%2FMybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[传统的JDBC编程JDBC(Java Data Base Connectivity) 是JAVA提供的数据库访问规范。典型的桥接模式，将各种数据库的访问抽象成一个同一的接口，再针对各种数据库，具体的实现。 初始化。（注册驱动，配置URL，Username，Password等配置）。Ｃlass.forName 是将具体的 Driver Class 加载到 JVM，然后通过它的静态初始化方法，把自身注册到 DriverManager 中。 获取Connection连接（通过 DriverManager 或者 DataSource ）。DriverManager 是典型的工厂方法模式，利用 URL的格式和参数，来创建对应的 Connection。 创建 Statement (包括PrepareStatement和CallableStatement) ，设置参数，执行SQL，查询请求会获取到ResultSet 通过ResultSet获得一行或多行数据。通过代码转换成POJO对象 关闭资源（ResultSet，Statement和Connection） 如果用到事务，还需要主动commit，以及捕获异常，然后rollback 这是通过JDBC操作数据库的一个标准流程，但是存在着很多问题： 工作量相对较大，大量重复的样板代码。重复是个坏味道; 需要对JDBC中可能出现的异常进行捕捉，处理，并且正确的关闭资源。 需要程序员自己解决 SQL 注入等安全问题 ORM由于JDBC的缺陷，实际工作中很少直接使用它(??) 于是提出了对象关系映射模型(ORM, Object Relational Mapping)。ORM就是关系型数据库表和简单Java对象( Plain Ordinary Java Object, 简称POJO)的映射关系模型。 Hibernate Hibernate 是一个流行的ORM框架，它具有以下特点： 消除了代码的映射规则，把它分离到XML或者注解的配置里 无需再手动管理数据库连接 无需再操作多个对象，只需要session即可，也只需要关闭session一个资源 但是它也是一个比较重的框架，基于全映射；不支持动态SQL；多表关联和复杂的SQL支持较差；不能很好的支持存储过程；虽然有HQL，但是性能较差 MyBatis MyBatis是一个半自动的持久化框架，它包含了SQL Maps和DAO(Data Access Objects)。除了提供映射关系以外，还需要我们自己提供SQL语句。它的映射文件包含了以下三个部分： SQL 映射规则 POJO 总结 JDBC在目前很少用到，它需要提供太多的代码，复杂的操作，还极其容易出问题 HIberate是一个流行全自动ORM的框架，但是因为它包装过多，失去了灵活性和性能 MyBatis是一个半自动的ORM框架，它提供了丰富而又灵活的功能。唯一的缺点是需要自己实现SQL，但也就是因为这样，给了程序员更好的灵活性。]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
        <tag>Database</tag>
      </tags>
  </entry>
</search>
